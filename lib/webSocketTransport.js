/**
 * WebSocket transport.
 *
 * This module is responsible for tunneling Organiq protocol requests over a
 * WebSocket connection. It may be used as a transport for any of device
 * containers, client handlers, or gateway servers.
 *
 * The transport does not maintain any state information concerning which
 * devices or applications are connected on either side of a connection. It is
 * the responsibility of the device and client containers to do so.
 *
 * Messages sent:
 *  REGISTER, DEREGISTER - administrative requests sent by a local device
 *    container to a remote gateway.
 *  CONNECT, DISCONNECT - administrative requests sent by a local application
 *    client to a remote gateway.
 *  PUT, NOTIFY - Device notifications sent from a local device container to
 *    remote application clients.
 *  GET, SET, INVOKE, SUBSCRIBE, CONFIG - Application requests sent from a local
 *    application client to a remote device container.
 *
 * Messages received:
 *  REGISTER, DEREGISTER - administrative requests sent by a remote device
 *    container to a local gateway.
 *  CONNECT, DISCONNECT - administrative requests sent by a remote application
 *    client to a local gateway.
 *  GET, SET, INVOKE, SUBSCRIBE, CONFIG - Application requests sent from a
 *    remote application client (possibly via a gateway). Forwarded to local
 *    device container.
 *  PUT, NOTIFY - Device notifications sent from a remote device container
 *    (possibly via a gateway). Forwarded to local application client.
 *
 * Requests in both directions may be overlapped; that is, multiple requests
 * may be outstanding at any given time, and responses to those requests may
 * come in any order. To facilitate multiplexing, each request has an associated
 * `reqid` property (assigned by the sender) which is included in the RESPONSE
 * sent by the responder.
 *
 * The format for both device and administrative requests is a JSON-
 * formatted WebSocketRequest object.
 *
 *  `reqid` - Unique request id generated by sender
 *  `deviceid` -
 *  `method` -
 *  `identifier` -
 *  `value` -
 *
 * Requests always include a `method`
 * and unique `reqid`, with slightly different properties depending on
 * request type. Responses to requests are indicated by method=`RESPONSE`,
 * and have the following additional properties:
 *  `reqid` - the value of reqid from the request message
 *  `success` - a boolean that is true if the request was successful
 *  `res` - on success, a JavaScript object representing the returned value
 *  `err` - on failure, a JavaScript Error object
 */

/**
 * Module Dependencies.
 */
var when_ = require('when');
var debug = require('debug')('organiq:websocket');
var OrganiqRequest = require('./request.js');
var EventEmitter = require('events').EventEmitter;
var util = require('util');

/**
 * Export WebSocketApi factory function.
 */
module.exports = WebSocketTransport;

var gatewayCommands = ['REGISTER', 'DEREGISTER', 'CONNECT', 'DISCONNECT'];
var downstreamCommands = ['GET', 'SET', 'INVOKE', 'SUBSCRIBE', 'DESCRIBE', 'CONFIG'];
var upstreamCommands = ['PUT', 'NOTIFY'];
var responseCommand = ['RESPONSE'];
void(responseCommand);


function isDownstreamCommand(method) {
  return downstreamCommands.indexOf(method) !== -1;
}

function isUpstreamCommand(method) {
  return upstreamCommands.indexOf(method) !== -1;
}

function isGatewayCommand(method) {
  return gatewayCommands.indexOf(method) !== -1;
}
void(isGatewayCommand);

//var MAX_SAFE_INTEGER = 9007199254740991;
//function newId() {
//  return Math.floor(Math.random() * MAX_SAFE_INTEGER).toString();
//}

var DEFAULT_REQUEST_TIMEOUT = 5000;   // five seconds

function webSocketRequestToOrganiqRequest(msg) {
  var r = OrganiqRequest;
  switch (msg.method) {
    case 'GET': return r.get(msg.deviceid, msg.identifier);
    case 'SET': return r.set(msg.deviceid, msg.identifier, msg.value);
    case 'INVOKE': return r.invoke(msg.deviceid, msg.identifier, msg.value);
    case 'SUBSCRIBE': return r.subscribe(msg.deviceid, msg.identifier);
    case 'DESCRIBE': return r.describe(msg.deviceid, msg.identifier);
    case 'CONFIG': return r.config(msg.deviceid, msg.identifier, msg.value);
    case 'PUT': return r.put(msg.deviceid, msg.identifier, msg.value);
    case 'NOTIFY': return r.notify(msg.deviceid, msg.identifier, msg.value);
    default:
      throw new Error('Invalid WebSocket method: ' + msg.method);
  }
}

function OrganiqToWSRequest(req) {
  var msg = {deviceid: req.deviceid, method: req.method, identifier: req.identifier};
  switch (req.method) {
    case 'GET': return msg;
    case 'SET': msg.value = req.value; return msg;
    case 'INVOKE': msg.value = req.params; return msg;
    case 'SUBSCRIBE': return msg;
    case 'DESCRIBE': return msg;
    case 'CONFIG': msg.value = req.value; return msg;
    case 'PUT': msg.value = req.value; return msg;
    case 'NOTIFY': msg.value = req.params; return msg;
    case 'REGISTER': return msg;
    case 'DEREGISTER': return msg;
    case 'CONNECT': return msg;
    case 'DISCONNECT': return msg;
    case 'INSTALL': return msg;
    case 'UNINSTALL': return msg;
    default:
      throw new Error('Invalid OrganiqRequest method: ' + msg.method);
  }
}

/**
 * @name Dispatcher
 * @property {function(OrganiqRequest)} dispatch - method to dispatch OrganiqRequest
 */

/**
 * WebSocket Connection
 *
 * This object manages the connection between the local node and a remote
 * gateway. The only state it maintains is related to multiplexing messages.
 *
 * @param {Dispatcher} downstream The dispatcher to invoke when downstream
 *  messages are received from the network peer. This is normally a local device
 *  container.
 * @param {Dispatcher} upstream The dispatcher to invoke when upstream messages
 *  are received from the network peer. This is normally a client application
 *  container.
 * @param {Dispatcher} driver The dispatcher to invoke when messages
 *  are received from the network peer for a driver.
 * @param {object} options
 * @param {object} options.namespace
 * @param {object} options.requestTimeout
 *
 * @returns {WebSocketTransport}
 *
 */
function WebSocketTransport(downstream, upstream, driver, options) {
  if (!(this instanceof WebSocketTransport)) {
    return new WebSocketTransport(downstream, upstream, options);
  }
  options = options || {};
  var REQUEST_TIMEOUT = options.requestTimeout || DEFAULT_REQUEST_TIMEOUT;

  var requests = {};      // outstanding server-originated requests, by reqid
  var _reqid = 0;         // request ID of last server-originated request
  var ws = null;
  var self = this;

  // public interface
  this.connectionHandler = webSocketApiConnectionHandler;
  this.connected = false;
  this.dispatch = dispatch;
  this.dispatchFromDriver = dispatchFromDriver;

  /**
   * Connection handler function.
   *
   * This function should be installed as the 'open' handler for a client-side
   * WebSocket.
   *
   * var ws = new WebSocket(...);
   * ws.on('open', handler)
   *
   * @params {WebSocket|undefined} A new WebSocket connection. If not specified,
   *  it is assumed that `this` refers to the WebSocket object.
   */
  function webSocketApiConnectionHandler(ws_) {
    ws = ws_ || this;

    ws.on('message', processMessage);
    ws.on('close', processClose);
    ws.on('error', processError);

    self.connected = true;
    self.emit('connect');
  }


  /**
   * WebSocket message handler.
   *
   * @param {String} data Data provided by the underlying WebSocket provider
   * @param {Object} flags includes `binary` property as boolean
   */
  function processMessage(data, flags) {
    // Check for (unsupported) binary message
    if (flags.binary) {
      throw new Error("Invalid (binary) message received.");
    }

    // Parse and validate the incoming message
    var msg;
    try {
      msg = JSON.parse(data);
    }
    catch (e) {
      debug('Invalid (non-JSON) message received.');
    }

    if (!msg || !msg.reqid || !msg.method) {
      throw new Error('Invalid message (missing reqid or method)');
    }

    if (msg.method !== 'RESPONSE') {
      debug('[*' + msg.reqid + ']: Received ' + msg.method + ' ' + msg.identifier +
            '(' + msg.value + ') -> ' + msg.deviceid + (msg.isForDriver ? ' [for driver]' : ''));
    }
    var method = msg.method;

    // Responses are handled by resolve-ing or reject-ing the promise that
    // was returned to the caller when the original request was made.
    if (method === 'RESPONSE') {
      var deferred = requests[msg.reqid];
      delete requests[msg.reqid];

      if (!deferred) {
        debug('RESPONSE received but no pending request. Cancelled or timed out?');
      } else {
        if (msg.success) {
          debug('[' + msg.reqid + ']: Received RESPONSE (' + msg.res + ')');
          deferred.resolve(msg.res);
        } else {
          debug('[' + msg.reqid + ']: Received RESPONSE ERROR(' + msg.err + ')');
          deferred.reject(new Error(msg.err));
        }
      }
    }

    else if (msg.isForDriver) {
      var reqDriver = webSocketRequestToOrganiqRequest(msg);
      return driver.dispatch(reqDriver).then(function(res) {
        sendResponse(msg, res);
      }).catch(function(err) {
        debug('dispatch to driver failed: ' + err);
        var errMessage = (err instanceof Error) ? err.message : err;
        sendFailureResponse(msg, errMessage);
      });
    }

    // Downstream requests are dispatched to the local router.
    else if (isDownstreamCommand(method)) {
      var req = webSocketRequestToOrganiqRequest(msg);

      return downstream.dispatch(req).then(function (res) {
        sendResponse(msg, res);
      }).catch(function (err) {
        debug('dispatch failed: ' + err);
        var errMessage = (err instanceof Error) ? err.message : err;
        sendFailureResponse(msg, errMessage);
      });
    }

    // Upstream requests go up to application clients
    else if (isUpstreamCommand(method)) {
      var reqUp = webSocketRequestToOrganiqRequest(msg);

      return upstream.dispatch(reqUp).then(function (res) {
        sendResponse(msg, res);
      }).catch(function (err) {
        debug('dispatch failed: ' + err);
        var errMessage = (err instanceof Error) ? err.message : err;
        sendFailureResponse(msg, errMessage);
      });
    }

    else {
      // Gateway commands should not come to client.
      throw new Error(
        'Invalid message received: invalid method \'' + method + '\'');
    }
  }


  /**
   * Handle a closed WebSocket connection (via ws.on('close')).
   *
   * This method cleans up all state associated with the client connection.
   */
  function processClose() {
    debug('websocket closed.');
    self.connected = false;
    self.emit('disconnect');
    for (var reqid in requests) {
      if (requests.hasOwnProperty(reqid)) {
        var deferred = requests[reqid];
        deferred.reject(new Error('Connection was closed.'));
        delete requests[deferred];
      }
    }
  }


  /**
   * Handle an error raised on the WebSocket connection (via ws.on('error')).
   */
  function processError(err) {
    debug('websocket error: ' + err);
  }


  /**
   * Deliver a WebSocket protocol request to the gateway.
   *
   * @param msg
   * @param msg.method
   * @param msg.isFromDriver
   * @param msg.deviceid
   * @param msg.identifier
   * @param msg.value
   *
   * @returns {Promise|{then, catch, finally}|deferred.promise}
   */
  function sendWebSocketRequest(msg) {
    debug('[' + parseInt(_reqid+1) + ']: Sending ' + msg.method + ' ' + msg.identifier +
          '(' + msg.value + ') -> ' + msg.deviceid + (msg.isFromDriver ? ' [from driver]':'')
          + (msg.isForDriver ? ' [for driver]' : ''));
    var deferred = when_.defer();
    msg.reqid = ++_reqid;
    requests[msg.reqid] = deferred;
    ws.send(JSON.stringify(msg), function ack(err) {
      if (err) {
        delete requests[msg.reqid];
        deferred.reject(err);
      }
    });
    return deferred.promise;
  }


  function cancelRequest(msg) {
    if (typeof requests[msg.reqid] !== 'undefined') {
      delete requests[msg.reqid];
      // deferred.reject(cancelled) ?
    }
  }


  /**
   * Send a successful response for a request previously received.
   *
   * @param req
   * @param res
   */
  function sendResponse(req, res) {
    debug('[*' + req.reqid + ']: Sending ' + 'RESPONSE to ' + req.method + ' (success)');
    var msg = {
      reqid: req.reqid, deviceid: req.deviceid, method: 'RESPONSE',
      success: true, res: res
    };
    ws.send(JSON.stringify(msg));
  }


  /**
   * Send a failure response for a request previously received.
   *
   * @param req
   * @param err
   */
  function sendFailureResponse(req, err) {
    debug('[*' + req.reqid + ']: Sending RESPONSE to ' + req.method + ' failed with err: ' + err);
    var msg = {
      reqid: req.reqid, deviceid: req.deviceid, method: 'RESPONSE',
      success: false, err: err
    };
    debug('request failed: ' + JSON.stringify(msg));
    ws.send(JSON.stringify(msg));
  }

  /**
   * Dispatch a request to the remote peer.
   *
   * @param {OrganiqRequest} req
   * @api
   */
  function dispatch(req) {
    var msg = OrganiqToWSRequest(req);
    return sendWebSocketRequest(msg)
      .timeout(REQUEST_TIMEOUT)
      .catch(when_.TimeoutError, function(e) {
        cancelRequest(msg);
        throw e;
      });
  }

  /**
   * Dispatch a request to the remote peer.
   *
   * @param {OrganiqRequest} req
   * @api
   */
  function dispatchFromDriver(req) {
    var msg = OrganiqToWSRequest(req);
    msg.isFromDriver = true;
    return sendWebSocketRequest(msg)
      .timeout(REQUEST_TIMEOUT)
      .catch(when_.TimeoutError, function(e) {
        cancelRequest(msg);
        throw e;
      });
  }
}
util.inherits(WebSocketTransport, EventEmitter);

